import { describeRoute, generateSpecs, validator, resolver, openAPIRouteHandler } from "hono-openapi"
import z from "zod/v4"
import {Log} from "../util/log.ts";
import {Bus} from "../bus";
import {Hono} from "hono";
import {lazy} from "../util/lazy.ts";
import {NamedError} from "../util/error.ts";
import {Instance} from "../project/instance.ts";
import {InstanceBootstrap} from "../project/bootstrap.ts";
import {cors} from "hono/cors";
import {Session} from "../session";
import {Message} from "../session/message.ts";
import {SessionPrompt} from "../session/prompt.ts";
import {BrowserLauncher} from "../browser/launcher.ts";
import {BrowserConnection} from "../browser/connection.ts";
import {BrowserTabs} from "../browser/tabs.ts";
import {Provider} from "../provider/provider.ts";
import {mapValues} from "remeda";
import {ModelsDev} from "../provider/models.ts";

const ERRORS = {
    400: {
        description: "Bad request",
        content: {
            "application/json": {
                schema: resolver(
                    z
                        .object({
                            data: z.record(z.string(), z.any()),
                        })
                        .meta({
                            ref: "Error",
                        }),
                ),
            },
        },
    },
} as const

export namespace Server {
    const log = Log.create({service: "server"})

    export const Event = {
        Connected: Bus.event("server.connected", z.object({})),
    }

    const app = new Hono()
    export const App = lazy(() =>
        app
            .onError((err, c) => {
                log.error("failed", {
                    error: err,
                })
                if (err instanceof NamedError) {
                    return c.json(err.toObject(), {
                        status: 400,
                    })
                }
                return c.json(new NamedError.Unknown({message: err.toString()}).toObject(), {
                    status: 400,
                })
            })
            .use(async (c, next) => {
                const skipLogging = c.req.path === "/log"
                if (!skipLogging) {
                    log.info("request", {
                        method: c.req.method,
                        path: c.req.path,
                    })
                }
                const start = Date.now()
                await next()
                if (!skipLogging) {
                    log.info("response", {
                        duration: Date.now() - start,
                    })
                }
            })
            .use(async (c, next) => {
                const directory = c.req.query("directory") ?? process.cwd()
                return Instance.provide({
                    directory,
                    init: InstanceBootstrap,
                    async fn() {
                        return next()
                    },
                })
            })
            .use(cors())
            .get(
                "/doc",
                openAPIRouteHandler(app, {
                    documentation: {
                        info: {
                            title: "open-browser",
                            version: "0.0.3",
                            description: "open-browser api",
                        },
                        openapi: "3.1.1",
                    },
                }),
            )
            .get(
                "/session",
                describeRoute({
                    description: "List all sessions",
                    operationId: "session.list",
                    responses: {
                        200: {
                            description: "List of sessions",
                            content: {
                                "application/json": {
                                    schema: resolver(Session.Info.array()),
                                },
                            },
                        },
                    },
                }),
                async (c) => {
                    const sessions = await Array.fromAsync(Session.list())
                    sessions.sort((a, b) => b.time.updated - a.time.updated)
                    return c.json(sessions)
                },
            )
            .get(
                "/config/providers",
                describeRoute({
                    description: "List all providers",
                    operationId: "config.providers",
                    responses: {
                        200: {
                            description: "List of providers",
                            content: {
                                "application/json": {
                                    schema: resolver(
                                        z.object({
                                            providers: ModelsDev.Provider.array(),
                                            default: z.record(z.string(), z.string()),
                                        }),
                                    ),
                                },
                            },
                        },
                    },
                }),
                async (c) => {
                    const providers = await Provider.list().then((x) => mapValues(x, (item) => item.info))
                    return c.json({
                        providers: Object.values(providers),
                        // @ts-ignore
                        default: mapValues(providers, (item) => Provider.sort(Object.values(item.models))[0].id),
                    })
                },
            )
            .get(
                "/session/:id",
                describeRoute({
                    description: "Get session",
                    operationId: "session.get",
                    responses: {
                        200: {
                            description: "Get session",
                            content: {
                                "application/json": {
                                    schema: resolver(Session.Info),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: Session.get.schema,
                    }),
                ),
                async (c) => {
                    const sessionID = c.req.valid("param").id
                    const session = await Session.get(sessionID)
                    return c.json(session)
                },
            )
            .get(
                "/session/:id/children",
                describeRoute({
                    description: "Get a session's children",
                    operationId: "session.children",
                    responses: {
                        200: {
                            description: "List of children",
                            content: {
                                "application/json": {
                                    schema: resolver(Session.Info.array()),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: Session.children.schema,
                    }),
                ),
                async (c) => {
                    const sessionID = c.req.valid("param").id
                    const session = await Session.children(sessionID)
                    return c.json(session)
                },
            )
            .post(
                "/session",
                describeRoute({
                    description: "Create a new session",
                    operationId: "session.create",
                    responses: {
                        ...ERRORS,
                        200: {
                            description: "Successfully created session",
                            content: {
                                "application/json": {
                                    schema: resolver(Session.Info),
                                },
                            },
                        },
                    },
                }),
                validator("json", Session.create.schema.optional()),
                async (c) => {
                    const body = c.req.valid("json") ?? {}
                    const session = await Session.create(body)
                    return c.json(session)
                },
            )
            .delete(
                "/session/:id",
                describeRoute({
                    description: "Delete a session and all its data",
                    operationId: "session.delete",
                    responses: {
                        200: {
                            description: "Successfully deleted session",
                            content: {
                                "application/json": {
                                    schema: resolver(z.boolean()),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: Session.remove.schema,
                    }),
                ),
                async (c) => {
                    await Session.remove(c.req.valid("param").id)
                    return c.json(true)
                },
            )
            .patch(
                "/session/:id",
                describeRoute({
                    description: "Update session properties",
                    operationId: "session.update",
                    responses: {
                        200: {
                            description: "Successfully updated session",
                            content: {
                                "application/json": {
                                    schema: resolver(Session.Info),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: z.string(),
                    }),
                ),
                validator(
                    "json",
                    z.object({
                        title: z.string().optional(),
                    }),
                ),
                async (c) => {
                    const sessionID = c.req.valid("param").id
                    const updates = c.req.valid("json")

                    const updatedSession = await Session.update(sessionID, (session) => {
                        if (updates.title !== undefined) {
                            session.title = updates.title
                        }
                    })

                    return c.json(updatedSession)
                },
            )
            .get(
                "/session/:id/message",
                describeRoute({
                    description: "List messages for a session",
                    operationId: "session.messages",
                    responses: {
                        200: {
                            description: "List of messages",
                            content: {
                                "application/json": {
                                    schema: resolver(Message.WithParts.array()),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: z.string().meta({ description: "Session ID" }),
                    }),
                ),
                async (c) => {
                    const messages = await Session.messages(c.req.valid("param").id)
                    // Exclude system prompt from response
                    const messagesWithoutSystem = messages.map(msg => ({
                        info: msg.info.role === "assistant"
                            ? { ...msg.info, system: undefined }
                            : msg.info,
                        parts: msg.parts
                    }))
                    return c.json(messagesWithoutSystem)
                },
            )
            .get(
                "/session/:id/message/:messageID",
                describeRoute({
                    description: "Get a message from a session",
                    operationId: "session.message",
                    responses: {
                        200: {
                            description: "Message",
                            content: {
                                "application/json": {
                                    schema: resolver(
                                        z.object({
                                            info: Message.Info,
                                            parts: Message.Part.array(),
                                        }),
                                    ),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: z.string().meta({ description: "Session ID" }),
                        messageID: z.string().meta({ description: "Message ID" }),
                    }),
                ),
                async (c) => {
                    const params = c.req.valid("param")
                    const message = await Session.getMessage({ sessionID: params.id, messageID: params.messageID })
                    return c.json(message)
                },
            )
            .post(
                "/session/:id/message",
                describeRoute({
                    description: "Create and send a new message to a session",
                    operationId: "session.prompt",
                    responses: {
                        200: {
                            description: "Created message",
                            content: {
                                "application/json": {
                                    schema: resolver(
                                        z.object({
                                            info: Message.Assistant,
                                            parts: Message.Part.array(),
                                        }),
                                    ),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: z.string().meta({ description: "Session ID" }),
                    }),
                ),
                validator("json", SessionPrompt.PromptInput.omit({ sessionID: true })),
                async (c) => {
                    const sessionID = c.req.valid("param").id
                    const body = c.req.valid("json")

                    // Check if browser is connected to this session
                    const hasConnection = await BrowserConnection.isConnected(sessionID)
                    if (!hasConnection) {
                        throw new NamedError.Unknown({
                            message: "No browser connected to this session. Please connect a browser first using POST /session/:id/browser/connect"
                        })
                    }

                    const msg = await SessionPrompt.prompt({ ...body, sessionID })
                    return c.json(msg)
                },
            )
            .post(
                "/browser/launch",
                describeRoute({
                    description: "Launch a new Chrome browser instance with remote debugging",
                    operationId: "browser.launch",
                    responses: {
                        ...ERRORS,
                        200: {
                            description: "Browser launched successfully",
                            content: {
                                "application/json": {
                                    schema: resolver(
                                        z.object({
                                            port: z.number(),
                                            pid: z.number(),
                                        })
                                    ),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "json",
                    z.object({
                        port: z.number().optional(),
                        headless: z.boolean().optional(),
                        stealth: z.boolean().optional(),
                        userDataDir: z.string().optional(),
                        args: z.array(z.string()).optional(),
                    }).optional()
                ),
                async (c) => {
                    const body = c.req.valid("json") ?? {}
                    const browser = await BrowserLauncher.launch(body)
                    return c.json({
                        port: browser.port,
                        pid: browser.pid,
                    })
                },
            )
            .post(
                "/session/:id/browser/connect",
                describeRoute({
                    description: "Connect a browser to this session via CDP",
                    operationId: "session.browser.connect",
                    responses: {
                        ...ERRORS,
                        200: {
                            description: "Browser connected successfully",
                            content: {
                                "application/json": {
                                    schema: resolver(
                                        z.object({
                                            host: z.string(),
                                            port: z.number(),
                                            target: z.string().optional(),
                                        })
                                    ),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: z.string().meta({ description: "Session ID" }),
                    }),
                ),
                validator(
                    "json",
                    z.object({
                        host: z.string().optional(),
                        port: z.number().optional(),
                        target: z.string().optional(),
                    }).optional()
                ),
                async (c) => {
                    const sessionID = c.req.valid("param").id
                    const body = c.req.valid("json") ?? {}

                    const client = await BrowserConnection.connect({
                        sessionID,
                        host: body.host,
                        port: body.port,
                        target: body.target,
                    })

                    return c.json({
                        host: client.host,
                        port: client.port,
                        target: client.target,
                    })
                },
            )
            .delete(
                "/browser/:port",
                describeRoute({
                    description: "Close a browser instance and disconnect all sessions",
                    operationId: "browser.close",
                    responses: {
                        ...ERRORS,
                        200: {
                            description: "Browser closed successfully",
                            content: {
                                "application/json": {
                                    schema: resolver(z.object({
                                        port: z.number(),
                                        disconnectedSessions: z.number(),
                                    })),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        port: z.coerce.number().meta({ description: "Browser port number" }),
                    }),
                ),
                async (c) => {
                    const port = c.req.valid("param").port

                    // Find and disconnect all sessions using this browser
                    const connections = BrowserConnection.state().connections
                    let disconnectedCount = 0

                    for (const [sessionID, client] of connections.entries()) {
                        if (client.port === port) {
                            await BrowserConnection.disconnect(sessionID)
                            disconnectedCount++
                        }
                    }

                    // Kill the browser process
                    await BrowserLauncher.kill(port)

                    return c.json({
                        port,
                        disconnectedSessions: disconnectedCount,
                    })
                },
            )
            .get(
                "/session/:id/browser/tabs",
                describeRoute({
                    description: "List all tabs in the browser for this session",
                    operationId: "session.browser.tabs.list",
                    responses: {
                        ...ERRORS,
                        200: {
                            description: "List of tabs",
                            content: {
                                "application/json": {
                                    schema: resolver(z.object({
                                        tabs: z.array(z.object({
                                            id: z.string(),
                                            url: z.string(),
                                            title: z.string(),
                                            createdAt: z.number(),
                                        })),
                                        activeTabId: z.string().nullable(),
                                    })),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: z.string().meta({ description: "Session ID" }),
                    }),
                ),
                async (c) => {
                    const sessionID = c.req.valid("param").id
                    const tabs = await BrowserTabs.listTabs(sessionID)
                    const activeTabId = await BrowserTabs.getActiveTabId(sessionID)

                    return c.json({
                        tabs: tabs.map(tab => ({
                            id: tab.id,
                            url: tab.url,
                            title: tab.title,
                            createdAt: tab.createdAt,
                        })),
                        activeTabId,
                    })
                },
            )
            .post(
                "/session/:id/browser/tab",
                describeRoute({
                    description: "Create a new tab in the browser",
                    operationId: "session.browser.tab.create",
                    responses: {
                        ...ERRORS,
                        200: {
                            description: "Tab created successfully",
                            content: {
                                "application/json": {
                                    schema: resolver(z.object({
                                        id: z.string(),
                                        url: z.string(),
                                        title: z.string(),
                                        createdAt: z.number(),
                                    })),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: z.string().meta({ description: "Session ID" }),
                    }),
                ),
                validator(
                    "json",
                    z.object({
                        url: z.string().url().optional(),
                    }).optional()
                ),
                async (c) => {
                    const sessionID = c.req.valid("param").id
                    const body = c.req.valid("json") ?? {}

                    const tab = await BrowserTabs.createTab({
                        sessionID,
                        url: body.url,
                    })

                    return c.json({
                        id: tab.id,
                        url: tab.url,
                        title: tab.title,
                        createdAt: tab.createdAt,
                    })
                },
            )
            .post(
                "/session/:id/browser/tab/:tabId/activate",
                describeRoute({
                    description: "Switch the active tab",
                    operationId: "session.browser.tab.activate",
                    responses: {
                        ...ERRORS,
                        200: {
                            description: "Tab switched successfully",
                            content: {
                                "application/json": {
                                    schema: resolver(z.object({
                                        tabId: z.string(),
                                    })),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: z.string().meta({ description: "Session ID" }),
                        tabId: z.string().meta({ description: "Tab ID to activate" }),
                    }),
                ),
                async (c) => {
                    const { id: sessionID, tabId } = c.req.valid("param")
                    await BrowserTabs.switchTab(sessionID, tabId)

                    return c.json({ tabId })
                },
            )
            .delete(
                "/session/:id/browser/tab/:tabId",
                describeRoute({
                    description: "Close a specific tab",
                    operationId: "session.browser.tab.close",
                    responses: {
                        ...ERRORS,
                        200: {
                            description: "Tab closed successfully",
                            content: {
                                "application/json": {
                                    schema: resolver(z.object({
                                        tabId: z.string(),
                                        remainingTabs: z.number(),
                                    })),
                                },
                            },
                        },
                    },
                }),
                validator(
                    "param",
                    z.object({
                        id: z.string().meta({ description: "Session ID" }),
                        tabId: z.string().meta({ description: "Tab ID to close" }),
                    }),
                ),
                async (c) => {
                    const { id: sessionID, tabId } = c.req.valid("param")
                    await BrowserTabs.closeTab(sessionID, tabId)

                    const remainingTabs = await BrowserTabs.listTabs(sessionID)

                    return c.json({
                        tabId,
                        remainingTabs: remainingTabs.length,
                    })
                },
            )
    )

    export function listen(opts: { port: number; hostname: string }) {
        const server = Bun.serve({
            port: opts.port,
            hostname: opts.hostname,
            idleTimeout: 0,
            fetch: App().fetch,
        })
        return server
    }
}
